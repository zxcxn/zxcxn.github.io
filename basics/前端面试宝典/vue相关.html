<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>4. vue相关 | 小鸟的博客</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/2.jpg">
    <meta name="description" content="我的个人博客">
    <link rel="preload" href="/assets/css/0.styles.7efa80d9.css" as="style"><link rel="preload" href="/assets/js/app.dd6f6bc7.js" as="script"><link rel="preload" href="/assets/js/2.469b0373.js" as="script"><link rel="preload" href="/assets/js/13.aa367da9.js" as="script"><link rel="prefetch" href="/assets/js/10.899e97b7.js"><link rel="prefetch" href="/assets/js/11.753f0002.js"><link rel="prefetch" href="/assets/js/12.c326389f.js"><link rel="prefetch" href="/assets/js/14.00cac946.js"><link rel="prefetch" href="/assets/js/15.d437ef35.js"><link rel="prefetch" href="/assets/js/16.8209c285.js"><link rel="prefetch" href="/assets/js/17.c5d8e5df.js"><link rel="prefetch" href="/assets/js/18.83a205bc.js"><link rel="prefetch" href="/assets/js/19.bb313a9a.js"><link rel="prefetch" href="/assets/js/3.86c86525.js"><link rel="prefetch" href="/assets/js/4.5ed19beb.js"><link rel="prefetch" href="/assets/js/5.92efac1b.js"><link rel="prefetch" href="/assets/js/6.be9822b3.js"><link rel="prefetch" href="/assets/js/7.3abbdfc8.js"><link rel="prefetch" href="/assets/js/8.4e8a55c0.js"><link rel="prefetch" href="/assets/js/9.bfaf77ed.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7efa80d9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小鸟的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础教程" class="dropdown-title"><span class="title">基础教程</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础教程" class="mobile-dropdown-title"><span class="title">基础教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basics/前端面试宝典/" class="nav-link">
  前端面试宝典
</a></li></ul></div></div><div class="nav-item"><a href="/project/" class="nav-link">
  项目实战
</a></div><div class="nav-item"><a href="/article/" class="nav-link">
  零散文章
</a></div><div class="nav-item"><a href="/association/" class="nav-link">
  一起学习
</a></div><div class="nav-item"><a href="/architect/" class="nav-link">
  前端架构师
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础教程" class="dropdown-title"><span class="title">基础教程</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础教程" class="mobile-dropdown-title"><span class="title">基础教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basics/前端面试宝典/" class="nav-link">
  前端面试宝典
</a></li></ul></div></div><div class="nav-item"><a href="/project/" class="nav-link">
  项目实战
</a></div><div class="nav-item"><a href="/article/" class="nav-link">
  零散文章
</a></div><div class="nav-item"><a href="/association/" class="nav-link">
  一起学习
</a></div><div class="nav-item"><a href="/architect/" class="nav-link">
  前端架构师
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/basics/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/" aria-current="page" class="sidebar-link">前端面试宝典</a></li><li><a href="/basics/前端面试宝典/css相关.html" class="sidebar-link">1. css相关</a></li><li><a href="/basics/前端面试宝典/js相关.html" class="sidebar-link">2. js相关</a></li><li><a href="/basics/前端面试宝典/浏览器网络相关.html" class="sidebar-link">3.浏览器网络相关</a></li><li><a href="/basics/前端面试宝典/vue相关.html" class="active sidebar-link">4. vue相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-1-vue-js-是什么" class="sidebar-link">4.1 Vue.js 是什么?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-2-vuex是什么-怎么使用-哪种功能场景使用它" class="sidebar-link">4.2 vuex是什么？怎么使用？哪种功能场景使用它？</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-3-vue-js-route-和-router-的区别" class="sidebar-link">4.3 Vue.js $route 和 $router 的区别?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-4-vue-js-如何让css只在当前组件中起作用" class="sidebar-link">4.4 Vue.js 如何让CSS只在当前组件中起作用?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-5-vue-js-的作用是什么" class="sidebar-link">4.5 Vue.js  的作用是什么?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-6-vue-js-指令v-el的作用是什么" class="sidebar-link">4.6 Vue.js 指令v-el的作用是什么?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-7-在-vue-js-中使用插件的步骤" class="sidebar-link">4.7 在 Vue.js 中使用插件的步骤？</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-8-vue-js-路由之间跳转" class="sidebar-link">4.8 Vue.js 路由之间跳转？</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-9-vue-js-组件中-data-什么时候可以使用对象" class="sidebar-link">4.9 Vue.js 组件中 data 什么时候可以使⽤对象?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-10-vue组件的生命周期" class="sidebar-link">4.10 Vue组件的生命周期</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-11-描述组件渲染和更新过程" class="sidebar-link">4.11 描述组件渲染和更新过程?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-12-组件中的-data为什么是一个函数" class="sidebar-link">4.12 组件中的 data为什么是一个函数?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-13-vue父子组件生命周期调用顺序" class="sidebar-link">4.13 Vue父子组件生命周期调用顺序?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-15-vue组件如何通信以及有哪些方式" class="sidebar-link">4.15 Vue组件如何通信以及有哪些方式?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-16-vue-js-怎么快速定位哪个组件出现性能问题" class="sidebar-link">4.16 Vue.js 怎么快速定位哪个组件出现性能问题?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-17-请列举出3个vue中常用的生命周期钩子函数" class="sidebar-link">4.17 请列举出3个Vue中常用的生命周期钩子函数?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-18-vue-js-和-react-区别" class="sidebar-link">4.18 Vue.js 和 react 区别?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-19-vue中事件绑定的原理" class="sidebar-link">4.19 Vue中事件绑定的原理?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-20-为什么v-for和v-if不能连用" class="sidebar-link">4.20 为什么V-for和v-if不能连用?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-21-ajax请求放在哪个生命周期中" class="sidebar-link">4.21 ajax请求放在哪个生命周期中?</a></li><li class="sidebar-sub-header"><a href="/basics/前端面试宝典/vue相关.html#_4-22-action-和-mutation区别" class="sidebar-link">4.22 action 和 mutation区别?</a></li></ul></li><li><a href="/basics/前端面试宝典/移动端相关.html" class="sidebar-link">5.移动端相关</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_4-vue相关"><a href="#_4-vue相关" class="header-anchor">#</a> 4. vue相关</h1> <h2 id="_4-1-vue-js-是什么"><a href="#_4-1-vue-js-是什么" class="header-anchor">#</a> 4.1 Vue.js 是什么?</h2> <h4 id="vue-读音-juː-类似于-view-是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是-vue-被设计为可以自底向上逐层应用。vue-的核心库只关注视图层-不仅易于上手-还便于与第三方库或既有项目整合。另一方面-当与现代化的工具链以及各种支持类库结合使用时-vue-也完全能够为复杂的单页应用提供驱动"><a href="#vue-读音-juː-类似于-view-是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是-vue-被设计为可以自底向上逐层应用。vue-的核心库只关注视图层-不仅易于上手-还便于与第三方库或既有项目整合。另一方面-当与现代化的工具链以及各种支持类库结合使用时-vue-也完全能够为复杂的单页应用提供驱动" class="header-anchor">#</a> Vue (读音 juː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动</h4> <h2 id="_4-2-vuex是什么-怎么使用-哪种功能场景使用它"><a href="#_4-2-vuex是什么-怎么使用-哪种功能场景使用它" class="header-anchor">#</a> 4.2 vuex是什么？怎么使用？哪种功能场景使用它？</h2> <h4 id="用来读取的状态集中放在-store-中-改变状态的方式是提交-mutations-这是个同步的事物-异步逻辑应该封装在-action-中。"><a href="#用来读取的状态集中放在-store-中-改变状态的方式是提交-mutations-这是个同步的事物-异步逻辑应该封装在-action-中。" class="header-anchor">#</a> ⽤来读取的状态集中放在 store 中； 改变状态的⽅式是提交 mutations ，这是个同步的事物； 异步逻辑应该封装在 action 中。</h4> <h4 id="场景有-单⻚应用中-组件之间的状态、音乐播放、登录状态、加入购物⻋"><a href="#场景有-单⻚应用中-组件之间的状态、音乐播放、登录状态、加入购物⻋" class="header-anchor">#</a> 场景有：单⻚应⽤中，组件之间的状态、⾳乐播放、登录状态、加⼊购物⻋</h4> <h4 id="state-vuex-使用单一状态树-即每个应用将仅仅包含一个-store-实例-但单一状态树和模块化并不冲突。存放的数据状态-不可以直接修改里面的数据。"><a href="#state-vuex-使用单一状态树-即每个应用将仅仅包含一个-store-实例-但单一状态树和模块化并不冲突。存放的数据状态-不可以直接修改里面的数据。" class="header-anchor">#</a> state ： Vuex 使⽤单⼀状态树,即每个应⽤将仅仅包含⼀个 store 实例，但单⼀状态树和模块化并不冲突。存放的数据状态，不可以直接修改⾥⾯的数据。</h4> <h4 id="mutations-mutations-定义的方法动态修改-vuex-的-store-中的状态或数据"><a href="#mutations-mutations-定义的方法动态修改-vuex-的-store-中的状态或数据" class="header-anchor">#</a> mutations ： mutations 定义的⽅法动态修改 Vuex 的 store 中的状态或数据</h4> <h4 id="getters-类似-vue-的计算属性-主要用来过滤一些数据。"><a href="#getters-类似-vue-的计算属性-主要用来过滤一些数据。" class="header-anchor">#</a> getters ：类似 vue 的计算属性，主要⽤来过滤⼀些数据。</h4> <h4 id="action-actions-可以理解为通过将-mutations-里面处里数据的方法变成可异步的处理数据的方法-简单的说就是异步操作数据。-view-层通过-store-dispath-来分发-action"><a href="#action-actions-可以理解为通过将-mutations-里面处里数据的方法变成可异步的处理数据的方法-简单的说就是异步操作数据。-view-层通过-store-dispath-来分发-action" class="header-anchor">#</a> action ： actions 可以理解为通过将 mutations ⾥⾯处⾥数据的⽅法变成可异步的处理数据的⽅法，简单的说就是异步操作数据。 view 层通过 store.dispath 来分发 action</h4> <h4 id="modules-项目特别复杂的时候-可以让每一个模块拥有自己的-state-、mutation-、-action-、-getters-使得结构非常清晰-方便管理。"><a href="#modules-项目特别复杂的时候-可以让每一个模块拥有自己的-state-、mutation-、-action-、-getters-使得结构非常清晰-方便管理。" class="header-anchor">#</a> modules ：项⽬特别复杂的时候，可以让每⼀个模块拥有⾃⼰的 state 、mutation 、 action 、 getters ，使得结构⾮常清晰，⽅便管理。</h4> <h2 id="_4-3-vue-js-route-和-router-的区别"><a href="#_4-3-vue-js-route-和-router-的区别" class="header-anchor">#</a> 4.3 Vue.js $route 和 $router 的区别?</h2> <h4 id="route-是-路由信息对象-包括-path-params-hash-query-fullpath-matched-name-等路由信息参数。而-router-是-路由实例-对象包括了路由的跳转方法-钩子函数等。"><a href="#route-是-路由信息对象-包括-path-params-hash-query-fullpath-matched-name-等路由信息参数。而-router-是-路由实例-对象包括了路由的跳转方法-钩子函数等。" class="header-anchor">#</a> $route 是“路由信息对象”，包括 path ， params ， hash ， query ，fullPath ， matched ， name 等路由信息参数。⽽ $router 是“路由实例”对象包括了路由的跳转⽅法，钩⼦函数等。</h4> <h2 id="_4-4-vue-js-如何让css只在当前组件中起作用"><a href="#_4-4-vue-js-如何让css只在当前组件中起作用" class="header-anchor">#</a> 4.4 Vue.js 如何让CSS只在当前组件中起作用?</h2> <div class="language- extra-class"><pre class="language-text"><code>将当前组件的 &lt;style&gt; 修改为 &lt;style scoped&gt;
</code></pre></div><h2 id="_4-5-vue-js-的作用是什么"><a href="#_4-5-vue-js-的作用是什么" class="header-anchor">#</a> 4.5 Vue.js <!----> 的作用是什么?</h2> <h4 id="包裹动态组件时-会缓存不活动的组件实例-主要用于保留-组件状态或避免重新渲染"><a href="#包裹动态组件时-会缓存不活动的组件实例-主要用于保留-组件状态或避免重新渲染" class="header-anchor">#</a> *包裹动态组件时，会缓存不活动的组件实例,主要⽤于保留 组件状态或避免重新渲染</h4> <h4 id="比如有一个列表和一个详情-那么用户就会经常执行打开详情-返回列表-打开详情-这样的话列表和详情都是一个频率很高的⻚面-那么就可以对列表-组件使用-进行缓存-这样用户每次返回列表的-时候-都能从缓存中快速渲染-而不是重新渲染"><a href="#比如有一个列表和一个详情-那么用户就会经常执行打开详情-返回列表-打开详情-这样的话列表和详情都是一个频率很高的⻚面-那么就可以对列表-组件使用-进行缓存-这样用户每次返回列表的-时候-都能从缓存中快速渲染-而不是重新渲染" class="header-anchor">#</a> *⽐如有⼀个列表和⼀个详情，那么⽤户就会经常执⾏打开详情=&gt;返回列表=&gt; 打开详情…这样的话列表和详情都是⼀个频率很⾼的⻚⾯，那么就可以对列表 组件使⽤ `进⾏缓存，这样⽤户每次返回列表的 时候，都能从缓存中快速渲染，⽽不是重新渲染</h4> <h2 id="_4-6-vue-js-指令v-el的作用是什么"><a href="#_4-6-vue-js-指令v-el的作用是什么" class="header-anchor">#</a> 4.6 Vue.js 指令v-el的作用是什么?</h2> <h4 id="提供一个在⻚面上已存在的-dom-元素作为-vue-实例的挂载目标-可以是-css-选择器-也可以是一个-htmlelement-实例。"><a href="#提供一个在⻚面上已存在的-dom-元素作为-vue-实例的挂载目标-可以是-css-选择器-也可以是一个-htmlelement-实例。" class="header-anchor">#</a> 提供⼀个在⻚⾯上已存在的 DOM 元素作为 Vue 实例的挂载⽬标.可以是 CSS 选择器，也可以是⼀个 HTMLElement 实例。</h4> <h2 id="_4-7-在-vue-js-中使用插件的步骤"><a href="#_4-7-在-vue-js-中使用插件的步骤" class="header-anchor">#</a> 4.7 在 Vue.js 中使用插件的步骤？</h2> <div class="language- extra-class"><pre class="language-text"><code>采⽤ ES6 的 import … from … 语法或 CommonJS 的 require() ⽅法引⼊插件
使⽤全局⽅法 Vue.use( plugin ) 使⽤插件,可以传⼊⼀个选项对象 Vue.use(MyPlugin, { someOption: true })
</code></pre></div><h2 id="_4-8-vue-js-路由之间跳转"><a href="#_4-8-vue-js-路由之间跳转" class="header-anchor">#</a> 4.8 Vue.js 路由之间跳转？</h2> <div class="language- extra-class"><pre class="language-text"><code> 声明式（标签跳转）:&lt;router-link :to=&quot;index&quot;&gt;
 编程式（ js跳转）:router.push('index')
</code></pre></div><h2 id="_4-9-vue-js-组件中-data-什么时候可以使用对象"><a href="#_4-9-vue-js-组件中-data-什么时候可以使用对象" class="header-anchor">#</a> 4.9 Vue.js 组件中 data 什么时候可以使⽤对象?</h2> <h4 id="组件复用时所有组件实例都会共享-data-如果-data-是对象的话-就会造成一个组件-修改-data-以后会影响到其他所有组件-所以需要将-data-写成函数-每次用到就调用-一次函数获得新的数据。"><a href="#组件复用时所有组件实例都会共享-data-如果-data-是对象的话-就会造成一个组件-修改-data-以后会影响到其他所有组件-所以需要将-data-写成函数-每次用到就调用-一次函数获得新的数据。" class="header-anchor">#</a> 组件复⽤时所有组件实例都会共享 data ，如果 data 是对象的话，就会造成⼀个组件 修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次⽤到就调⽤ ⼀次函数获得新的数据。</h4> <h4 id="当我们使用-new-vue-的方式的时候-无论我们将-data-设置为对象还是函数都是可-以的-因为-new-vue-的方式是生成一个根组件-该组件不会复用-也就不存在共享-data-的情况了"><a href="#当我们使用-new-vue-的方式的时候-无论我们将-data-设置为对象还是函数都是可-以的-因为-new-vue-的方式是生成一个根组件-该组件不会复用-也就不存在共享-data-的情况了" class="header-anchor">#</a> 当我们使⽤ new Vue() 的⽅式的时候，⽆论我们将 data 设置为对象还是函数都是可 以的，因为 new Vue() 的⽅式是⽣成⼀个根组件，该组件不会复⽤，也就不存在共享 data 的情况了</h4> <h2 id="_4-10-vue组件的生命周期"><a href="#_4-10-vue组件的生命周期" class="header-anchor">#</a> 4.10 Vue组件的生命周期</h2> <h4 id="总共分为8个阶段创建前-后-载入前-后-更新前-后-销毁前-后"><a href="#总共分为8个阶段创建前-后-载入前-后-更新前-后-销毁前-后" class="header-anchor">#</a> 总共分为8个阶段创建前/后，载⼊前/后，更新前/后，销毁前/后</h4> <h4 id="创建前-后-在-beforecreate-阶段-vue-实例的挂载元素-el-和数据对象-data-都为undefined-还未初始化。在-created-阶段-vue-实例的数据对象-data-有了-el还-没有"><a href="#创建前-后-在-beforecreate-阶段-vue-实例的挂载元素-el-和数据对象-data-都为undefined-还未初始化。在-created-阶段-vue-实例的数据对象-data-有了-el还-没有" class="header-anchor">#</a> *创建前/后： 在 beforeCreate 阶段， vue 实例的挂载元素 el 和数据对象 data 都为undefined ，还未初始化。在 created 阶段， vue 实例的数据对象 data 有了，el还 没有</h4> <h4 id="载入前-后-在-beforemount-阶段-vue-实例的-el-和-data-都初始化了-但还是挂载之前为虚拟的-dom-节点-data-message-还未替换。在-mounted-阶段-vue-实例挂载完成-data-message-成功渲染。"><a href="#载入前-后-在-beforemount-阶段-vue-实例的-el-和-data-都初始化了-但还是挂载之前为虚拟的-dom-节点-data-message-还未替换。在-mounted-阶段-vue-实例挂载完成-data-message-成功渲染。" class="header-anchor">#</a> *载⼊前/后：在 beforeMount 阶段， vue 实例的 $el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点， data.message 还未替换。在 mounted 阶段， vue 实例挂载完成， data.message 成功渲染。</h4> <h4 id="更新前-后-当-data-变化时-会触发-beforeupdate-和-updated-方法"><a href="#更新前-后-当-data-变化时-会触发-beforeupdate-和-updated-方法" class="header-anchor">#</a> *更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated ⽅法</h4> <h4 id="销毁前-后-在执行-destroy-方法后-对-data-的改变不会再触发周期函数-说明此时-vue-实例已经解除了事件监听以及和-dom-的绑定-但是-dom-结构依然存在"><a href="#销毁前-后-在执行-destroy-方法后-对-data-的改变不会再触发周期函数-说明此时-vue-实例已经解除了事件监听以及和-dom-的绑定-但是-dom-结构依然存在" class="header-anchor">#</a> *销毁前/后：在执⾏ destroy ⽅法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</h4> <h2 id="_4-11-描述组件渲染和更新过程"><a href="#_4-11-描述组件渲染和更新过程" class="header-anchor">#</a> 4.11 描述组件渲染和更新过程?</h2> <h4 id="渲染组件时-会通过vue-extend方法构建子组件的构造函数-并进行实例化。最终手动调用-mount-进行挂载。更新组件时会进行patchvnode流程-核心就是diff算法"><a href="#渲染组件时-会通过vue-extend方法构建子组件的构造函数-并进行实例化。最终手动调用-mount-进行挂载。更新组件时会进行patchvnode流程-核心就是diff算法" class="header-anchor">#</a> 渲染组件时，会通过Vue.extend方法构建子组件的构造函数，并进行实例化。最终手动调用$mount()进行挂载。更新组件时会进行patchVnode流程.核心就是diff算法</h4> <h2 id="_4-12-组件中的-data为什么是一个函数"><a href="#_4-12-组件中的-data为什么是一个函数" class="header-anchor">#</a> 4.12 组件中的 data为什么是一个函数?</h2> <h4 id="同一个组件被复用多次-会创建多个实例。这些实例用的是同一个构造函数-如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。"><a href="#同一个组件被复用多次-会创建多个实例。这些实例用的是同一个构造函数-如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。" class="header-anchor">#</a> 同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。</h4> <h2 id="_4-13-vue父子组件生命周期调用顺序"><a href="#_4-13-vue父子组件生命周期调用顺序" class="header-anchor">#</a> 4.13 Vue父子组件生命周期调用顺序?</h2> <h4 id="加载渲染过程-父beforecreate-父created-父beforemount-子beforecreate-子created-子beforemount-子mounted-父mounted"><a href="#加载渲染过程-父beforecreate-父created-父beforemount-子beforecreate-子created-子beforemount-子mounted-父mounted" class="header-anchor">#</a> 加载渲染过程:父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</h4> <h4 id="子组件更新过程-父beforeupdate-子beforeupdate-子updated-父updated"><a href="#子组件更新过程-父beforeupdate-子beforeupdate-子updated-父updated" class="header-anchor">#</a> 子组件更新过程:父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</h4> <h4 id="父组件更新过程-父beforeupdate-父updated"><a href="#父组件更新过程-父beforeupdate-父updated" class="header-anchor">#</a> 父组件更新过程: 父beforeUpdate -&gt; 父updated</h4> <h4 id="销毁过程-父beforedestroy-子beforedestroy-子destroyed-父destroyed"><a href="#销毁过程-父beforedestroy-子beforedestroy-子destroyed-父destroyed" class="header-anchor">#</a> 销毁过程:父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</h4> <h4 id="组件的调用顺序都是先父后子-渲染完成的顺序肯定是先子后父。组件的销毁操作是先父后子-销毁完成的顺序是先子后父。"><a href="#组件的调用顺序都是先父后子-渲染完成的顺序肯定是先子后父。组件的销毁操作是先父后子-销毁完成的顺序是先子后父。" class="header-anchor">#</a> 组件的调用顺序都是先父后子,渲染完成的顺序肯定是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</h4> <h2 id="_4-15-vue组件如何通信以及有哪些方式"><a href="#_4-15-vue组件如何通信以及有哪些方式" class="header-anchor">#</a> 4.15 Vue组件如何通信以及有哪些方式?</h2> <h4 id="父子间通信-父-子通过props、子-父-on、-emit"><a href="#父子间通信-父-子通过props、子-父-on、-emit" class="header-anchor">#</a> *父子间通信 父-&gt;子通过props、子-&gt; 父$on、$emit</h4> <h4 id="获取父子组件实例的方式-parent、-children"><a href="#获取父子组件实例的方式-parent、-children" class="header-anchor">#</a> *获取父子组件实例的方式$parent、$children</h4> <h4 id="在父组件中提供数据子组件进行消费-provide、inject"><a href="#在父组件中提供数据子组件进行消费-provide、inject" class="header-anchor">#</a> *在父组件中提供数据子组件进行消费 Provide、inject</h4> <h4 id="ref获取实例的方式调用组件的属性或者方法"><a href="#ref获取实例的方式调用组件的属性或者方法" class="header-anchor">#</a> *Ref获取实例的方式调用组件的属性或者方法</h4> <h4 id="event-bus-实现跨组件通信"><a href="#event-bus-实现跨组件通信" class="header-anchor">#</a> *Event Bus 实现跨组件通信</h4> <h4 id="vuex状态管理实现通信"><a href="#vuex状态管理实现通信" class="header-anchor">#</a> *Vuex状态管理实现通信</h4> <h2 id="_4-16-vue-js-怎么快速定位哪个组件出现性能问题"><a href="#_4-16-vue-js-怎么快速定位哪个组件出现性能问题" class="header-anchor">#</a> 4.16 Vue.js 怎么快速定位哪个组件出现性能问题?</h2> <h4 id="用-timeline-工具。-大意是通过-timeline-来查看每个函数的调用时常-定位出哪个函数的问题-从而能判断哪个组件出了问题。"><a href="#用-timeline-工具。-大意是通过-timeline-来查看每个函数的调用时常-定位出哪个函数的问题-从而能判断哪个组件出了问题。" class="header-anchor">#</a> ⽤ timeline ⼯具。 ⼤意是通过 timeline 来查看每个函数的调⽤时常，定位出哪个函数的问题，从⽽能判断哪个组件出了问题。</h4> <h2 id="_4-17-请列举出3个vue中常用的生命周期钩子函数"><a href="#_4-17-请列举出3个vue中常用的生命周期钩子函数" class="header-anchor">#</a> 4.17 请列举出3个Vue中常用的生命周期钩子函数?</h2> <h4 id="created-实例已经创建完成之后调用-在这一步-实例已经完成数据观测-属性和方法的运-算-watch-event-事件回调-然而-挂载阶段还没有开始-el-属性目前还不可⻅。"><a href="#created-实例已经创建完成之后调用-在这一步-实例已经完成数据观测-属性和方法的运-算-watch-event-事件回调-然而-挂载阶段还没有开始-el-属性目前还不可⻅。" class="header-anchor">#</a> created : 实例已经创建完成之后调⽤,在这⼀步,实例已经完成数据观测, 属性和⽅法的运 算, watch/event 事件回调. 然⽽, 挂载阶段还没有开始, $el 属性⽬前还不可⻅。</h4> <h4 id="mounted-el-被新创建的-vm-el-替换-并挂载到实例上去之后调用该钩子。如果-root-实例挂载了一个文档内元素-当-mounted-被调用时-vm-el-也在文档内。"><a href="#mounted-el-被新创建的-vm-el-替换-并挂载到实例上去之后调用该钩子。如果-root-实例挂载了一个文档内元素-当-mounted-被调用时-vm-el-也在文档内。" class="header-anchor">#</a> mounted : el 被新创建的 vm.$el 替换，并挂载到实例上去之后调⽤该钩⼦。如果 root 实例挂载了⼀个⽂档内元素，当 mounted 被调⽤时 vm.$el 也在⽂档内。</h4> <h4 id="activated-keep-alive-组件激活时用。"><a href="#activated-keep-alive-组件激活时用。" class="header-anchor">#</a> activated : keep-alive 组件激活时用。</h4> <h2 id="_4-18-vue-js-和-react-区别"><a href="#_4-18-vue-js-和-react-区别" class="header-anchor">#</a> 4.18 Vue.js 和 react 区别?</h2> <h4 id="相同点-都支持-ssr-都有-vdom-组件化开发-实现-webcomponents-规范-数据驱-动等。"><a href="#相同点-都支持-ssr-都有-vdom-组件化开发-实现-webcomponents-规范-数据驱-动等。" class="header-anchor">#</a> 相同点:都⽀持 ssr ，都有 vdom ，组件化开发，实现 webComponents 规范，数据驱 动等。</h4> <h4 id="不同点-vue-是双向数据流-当然为了实现单数据流方便管理组件状态-vuex-便出现了-react-是单向数据流。-vue-的-vdom-是追踪每个组件的依赖关系-不会渲染整个组件树-react-每当应该状态被改变时-全部子组件都会-re-render"><a href="#不同点-vue-是双向数据流-当然为了实现单数据流方便管理组件状态-vuex-便出现了-react-是单向数据流。-vue-的-vdom-是追踪每个组件的依赖关系-不会渲染整个组件树-react-每当应该状态被改变时-全部子组件都会-re-render" class="header-anchor">#</a> 不同点：vue 是双向数据流（当然为了实现单数据流⽅便管理组件状态， vuex 便出现了）， react 是单向数据流。 vue 的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树， react 每当应该状态被改变时，全部⼦组件都会 re-render</h4> <h2 id="_4-19-vue中事件绑定的原理"><a href="#_4-19-vue中事件绑定的原理" class="header-anchor">#</a> 4.19 Vue中事件绑定的原理?</h2> <h4 id="原生dom事件的绑定-采用的是addeventlistener实现"><a href="#原生dom事件的绑定-采用的是addeventlistener实现" class="header-anchor">#</a> 原生dom事件的绑定,采用的是addEventListener实现</h4> <h4 id="组件绑定事件采用的是-on方法"><a href="#组件绑定事件采用的是-on方法" class="header-anchor">#</a> 组件绑定事件采用的是$on方法</h4> <h2 id="_4-20-为什么v-for和v-if不能连用"><a href="#_4-20-为什么v-for和v-if不能连用" class="header-anchor">#</a> 4.20 为什么V-for和v-if不能连用?</h2> <h4 id="v-for会比v-if的优先级高一些-如果连用的话会把v-if给每个元素都添加一下-会造成性能问题"><a href="#v-for会比v-if的优先级高一些-如果连用的话会把v-if给每个元素都添加一下-会造成性能问题" class="header-anchor">#</a> v-for会比v-if的优先级高一些,如果连用的话会把v-if给每个元素都添加一下,会造成性能问题</h4> <h2 id="_4-21-ajax请求放在哪个生命周期中"><a href="#_4-21-ajax请求放在哪个生命周期中" class="header-anchor">#</a> 4.21 ajax请求放在哪个生命周期中?</h2> <h4 id="在created的时候-视图中的dom并没有渲染出来-所以此时如果直接去操dom节点-无法找到相关的元素"><a href="#在created的时候-视图中的dom并没有渲染出来-所以此时如果直接去操dom节点-无法找到相关的元素" class="header-anchor">#</a> 在created的时候，视图中的dom并没有渲染出来，所以此时如果直接去操dom节点，无法找到相关的元素</h4> <h4 id="在mounted中-由于此时dom已经渲染出来了-所以可以直接操作dom节点。一般情况下都放到mounted中-保证逻辑的统一性-因为生命周期是同步执行的-ajax是异步执行的。"><a href="#在mounted中-由于此时dom已经渲染出来了-所以可以直接操作dom节点。一般情况下都放到mounted中-保证逻辑的统一性-因为生命周期是同步执行的-ajax是异步执行的。" class="header-anchor">#</a> 在mounted中，由于此时dom已经渲染出来了，所以可以直接操作dom节点。一般情况下都放到mounted中,保证逻辑的统一性,因为生命周期是同步执行的，ajax是异步执行的。</h4> <h2 id="_4-22-action-和-mutation区别"><a href="#_4-22-action-和-mutation区别" class="header-anchor">#</a> 4.22 action 和 mutation区别?</h2> <h4 id="mutation是同步更新数据-内部会进行是否为异步方式更新数据的检测-。"><a href="#mutation是同步更新数据-内部会进行是否为异步方式更新数据的检测-。" class="header-anchor">#</a> mutation是同步更新数据(内部会进行是否为异步方式更新数据的检测)。</h4> <h4 id="action-异步操作-可以获取数据后调佣mutation提交最终数据。"><a href="#action-异步操作-可以获取数据后调佣mutation提交最终数据。" class="header-anchor">#</a> action 异步操作，可以获取数据后调佣mutation提交最终数据。</h4></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/basics/前端面试宝典/浏览器网络相关.html" class="prev">
        3.浏览器网络相关
      </a></span> <span class="next"><a href="/basics/前端面试宝典/移动端相关.html">
        5.移动端相关
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.dd6f6bc7.js" defer></script><script src="/assets/js/2.469b0373.js" defer></script><script src="/assets/js/13.aa367da9.js" defer></script>
  </body>
</html>
