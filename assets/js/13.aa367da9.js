(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{360:function(t,a,e){"use strict";e.r(a);var r=e(42),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_4-vue相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue相关"}},[t._v("#")]),t._v(" 4. vue相关")]),t._v(" "),e("h2",{attrs:{id:"_4-1-vue-js-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-vue-js-是什么"}},[t._v("#")]),t._v(" 4.1 Vue.js 是什么?")]),t._v(" "),e("h4",{attrs:{id:"vue-读音-juː-类似于-view-是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是-vue-被设计为可以自底向上逐层应用。vue-的核心库只关注视图层-不仅易于上手-还便于与第三方库或既有项目整合。另一方面-当与现代化的工具链以及各种支持类库结合使用时-vue-也完全能够为复杂的单页应用提供驱动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-读音-juː-类似于-view-是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是-vue-被设计为可以自底向上逐层应用。vue-的核心库只关注视图层-不仅易于上手-还便于与第三方库或既有项目整合。另一方面-当与现代化的工具链以及各种支持类库结合使用时-vue-也完全能够为复杂的单页应用提供驱动"}},[t._v("#")]),t._v(" Vue (读音 juː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动")]),t._v(" "),e("h2",{attrs:{id:"_4-2-vuex是什么-怎么使用-哪种功能场景使用它"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-vuex是什么-怎么使用-哪种功能场景使用它"}},[t._v("#")]),t._v(" 4.2 vuex是什么？怎么使用？哪种功能场景使用它？")]),t._v(" "),e("h4",{attrs:{id:"用来读取的状态集中放在-store-中-改变状态的方式是提交-mutations-这是个同步的事物-异步逻辑应该封装在-action-中。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用来读取的状态集中放在-store-中-改变状态的方式是提交-mutations-这是个同步的事物-异步逻辑应该封装在-action-中。"}},[t._v("#")]),t._v(" ⽤来读取的状态集中放在 store 中； 改变状态的⽅式是提交 mutations ，这是个同步的事物； 异步逻辑应该封装在 action 中。")]),t._v(" "),e("h4",{attrs:{id:"场景有-单⻚应用中-组件之间的状态、音乐播放、登录状态、加入购物⻋"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景有-单⻚应用中-组件之间的状态、音乐播放、登录状态、加入购物⻋"}},[t._v("#")]),t._v(" 场景有：单⻚应⽤中，组件之间的状态、⾳乐播放、登录状态、加⼊购物⻋")]),t._v(" "),e("h4",{attrs:{id:"state-vuex-使用单一状态树-即每个应用将仅仅包含一个-store-实例-但单一状态树和模块化并不冲突。存放的数据状态-不可以直接修改里面的数据。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#state-vuex-使用单一状态树-即每个应用将仅仅包含一个-store-实例-但单一状态树和模块化并不冲突。存放的数据状态-不可以直接修改里面的数据。"}},[t._v("#")]),t._v(" state ： Vuex 使⽤单⼀状态树,即每个应⽤将仅仅包含⼀个 store 实例，但单⼀状态树和模块化并不冲突。存放的数据状态，不可以直接修改⾥⾯的数据。")]),t._v(" "),e("h4",{attrs:{id:"mutations-mutations-定义的方法动态修改-vuex-的-store-中的状态或数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutations-mutations-定义的方法动态修改-vuex-的-store-中的状态或数据"}},[t._v("#")]),t._v(" mutations ： mutations 定义的⽅法动态修改 Vuex 的 store 中的状态或数据")]),t._v(" "),e("h4",{attrs:{id:"getters-类似-vue-的计算属性-主要用来过滤一些数据。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getters-类似-vue-的计算属性-主要用来过滤一些数据。"}},[t._v("#")]),t._v(" getters ：类似 vue 的计算属性，主要⽤来过滤⼀些数据。")]),t._v(" "),e("h4",{attrs:{id:"action-actions-可以理解为通过将-mutations-里面处里数据的方法变成可异步的处理数据的方法-简单的说就是异步操作数据。-view-层通过-store-dispath-来分发-action"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#action-actions-可以理解为通过将-mutations-里面处里数据的方法变成可异步的处理数据的方法-简单的说就是异步操作数据。-view-层通过-store-dispath-来分发-action"}},[t._v("#")]),t._v(" action ： actions 可以理解为通过将 mutations ⾥⾯处⾥数据的⽅法变成可异步的处理数据的⽅法，简单的说就是异步操作数据。 view 层通过 store.dispath 来分发 action")]),t._v(" "),e("h4",{attrs:{id:"modules-项目特别复杂的时候-可以让每一个模块拥有自己的-state-、mutation-、-action-、-getters-使得结构非常清晰-方便管理。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#modules-项目特别复杂的时候-可以让每一个模块拥有自己的-state-、mutation-、-action-、-getters-使得结构非常清晰-方便管理。"}},[t._v("#")]),t._v(" modules ：项⽬特别复杂的时候，可以让每⼀个模块拥有⾃⼰的 state 、mutation 、 action 、 getters ，使得结构⾮常清晰，⽅便管理。")]),t._v(" "),e("h2",{attrs:{id:"_4-3-vue-js-route-和-router-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-vue-js-route-和-router-的区别"}},[t._v("#")]),t._v(" 4.3 Vue.js $route 和 $router 的区别?")]),t._v(" "),e("h4",{attrs:{id:"route-是-路由信息对象-包括-path-params-hash-query-fullpath-matched-name-等路由信息参数。而-router-是-路由实例-对象包括了路由的跳转方法-钩子函数等。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#route-是-路由信息对象-包括-path-params-hash-query-fullpath-matched-name-等路由信息参数。而-router-是-路由实例-对象包括了路由的跳转方法-钩子函数等。"}},[t._v("#")]),t._v(" $route 是“路由信息对象”，包括 path ， params ， hash ， query ，fullPath ， matched ， name 等路由信息参数。⽽ $router 是“路由实例”对象包括了路由的跳转⽅法，钩⼦函数等。")]),t._v(" "),e("h2",{attrs:{id:"_4-4-vue-js-如何让css只在当前组件中起作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-vue-js-如何让css只在当前组件中起作用"}},[t._v("#")]),t._v(" 4.4 Vue.js 如何让CSS只在当前组件中起作用?")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("将当前组件的 <style> 修改为 <style scoped>\n")])])]),e("h2",{attrs:{id:"_4-5-vue-js-的作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-vue-js-的作用是什么"}},[t._v("#")]),t._v(" 4.5 Vue.js "),e("keep-alive"),t._v(" 的作用是什么?")],1),t._v(" "),e("h4",{attrs:{id:"包裹动态组件时-会缓存不活动的组件实例-主要用于保留-组件状态或避免重新渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包裹动态组件时-会缓存不活动的组件实例-主要用于保留-组件状态或避免重新渲染"}},[t._v("#")]),t._v(" *包裹动态组件时，会缓存不活动的组件实例,主要⽤于保留 组件状态或避免重新渲染")]),t._v(" "),e("h4",{attrs:{id:"比如有一个列表和一个详情-那么用户就会经常执行打开详情-返回列表-打开详情-这样的话列表和详情都是一个频率很高的⻚面-那么就可以对列表-组件使用-进行缓存-这样用户每次返回列表的-时候-都能从缓存中快速渲染-而不是重新渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#比如有一个列表和一个详情-那么用户就会经常执行打开详情-返回列表-打开详情-这样的话列表和详情都是一个频率很高的⻚面-那么就可以对列表-组件使用-进行缓存-这样用户每次返回列表的-时候-都能从缓存中快速渲染-而不是重新渲染"}},[t._v("#")]),t._v(" *⽐如有⼀个列表和⼀个详情，那么⽤户就会经常执⾏打开详情=>返回列表=> 打开详情…这样的话列表和详情都是⼀个频率很⾼的⻚⾯，那么就可以对列表 组件使⽤ `进⾏缓存，这样⽤户每次返回列表的 时候，都能从缓存中快速渲染，⽽不是重新渲染")]),t._v(" "),e("h2",{attrs:{id:"_4-6-vue-js-指令v-el的作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-vue-js-指令v-el的作用是什么"}},[t._v("#")]),t._v(" 4.6 Vue.js 指令v-el的作用是什么?")]),t._v(" "),e("h4",{attrs:{id:"提供一个在⻚面上已存在的-dom-元素作为-vue-实例的挂载目标-可以是-css-选择器-也可以是一个-htmlelement-实例。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提供一个在⻚面上已存在的-dom-元素作为-vue-实例的挂载目标-可以是-css-选择器-也可以是一个-htmlelement-实例。"}},[t._v("#")]),t._v(" 提供⼀个在⻚⾯上已存在的 DOM 元素作为 Vue 实例的挂载⽬标.可以是 CSS 选择器，也可以是⼀个 HTMLElement 实例。")]),t._v(" "),e("h2",{attrs:{id:"_4-7-在-vue-js-中使用插件的步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-在-vue-js-中使用插件的步骤"}},[t._v("#")]),t._v(" 4.7 在 Vue.js 中使用插件的步骤？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("采⽤ ES6 的 import … from … 语法或 CommonJS 的 require() ⽅法引⼊插件\n使⽤全局⽅法 Vue.use( plugin ) 使⽤插件,可以传⼊⼀个选项对象 Vue.use(MyPlugin, { someOption: true })\n")])])]),e("h2",{attrs:{id:"_4-8-vue-js-路由之间跳转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-vue-js-路由之间跳转"}},[t._v("#")]),t._v(" 4.8 Vue.js 路由之间跳转？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" 声明式（标签跳转）:<router-link :to=\"index\">\n 编程式（ js跳转）:router.push('index')\n")])])]),e("h2",{attrs:{id:"_4-9-vue-js-组件中-data-什么时候可以使用对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-vue-js-组件中-data-什么时候可以使用对象"}},[t._v("#")]),t._v(" 4.9 Vue.js 组件中 data 什么时候可以使⽤对象?")]),t._v(" "),e("h4",{attrs:{id:"组件复用时所有组件实例都会共享-data-如果-data-是对象的话-就会造成一个组件-修改-data-以后会影响到其他所有组件-所以需要将-data-写成函数-每次用到就调用-一次函数获得新的数据。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件复用时所有组件实例都会共享-data-如果-data-是对象的话-就会造成一个组件-修改-data-以后会影响到其他所有组件-所以需要将-data-写成函数-每次用到就调用-一次函数获得新的数据。"}},[t._v("#")]),t._v(" 组件复⽤时所有组件实例都会共享 data ，如果 data 是对象的话，就会造成⼀个组件 修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次⽤到就调⽤ ⼀次函数获得新的数据。")]),t._v(" "),e("h4",{attrs:{id:"当我们使用-new-vue-的方式的时候-无论我们将-data-设置为对象还是函数都是可-以的-因为-new-vue-的方式是生成一个根组件-该组件不会复用-也就不存在共享-data-的情况了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#当我们使用-new-vue-的方式的时候-无论我们将-data-设置为对象还是函数都是可-以的-因为-new-vue-的方式是生成一个根组件-该组件不会复用-也就不存在共享-data-的情况了"}},[t._v("#")]),t._v(" 当我们使⽤ new Vue() 的⽅式的时候，⽆论我们将 data 设置为对象还是函数都是可 以的，因为 new Vue() 的⽅式是⽣成⼀个根组件，该组件不会复⽤，也就不存在共享 data 的情况了")]),t._v(" "),e("h2",{attrs:{id:"_4-10-vue组件的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-10-vue组件的生命周期"}},[t._v("#")]),t._v(" 4.10 Vue组件的生命周期")]),t._v(" "),e("h4",{attrs:{id:"总共分为8个阶段创建前-后-载入前-后-更新前-后-销毁前-后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总共分为8个阶段创建前-后-载入前-后-更新前-后-销毁前-后"}},[t._v("#")]),t._v(" 总共分为8个阶段创建前/后，载⼊前/后，更新前/后，销毁前/后")]),t._v(" "),e("h4",{attrs:{id:"创建前-后-在-beforecreate-阶段-vue-实例的挂载元素-el-和数据对象-data-都为undefined-还未初始化。在-created-阶段-vue-实例的数据对象-data-有了-el还-没有"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建前-后-在-beforecreate-阶段-vue-实例的挂载元素-el-和数据对象-data-都为undefined-还未初始化。在-created-阶段-vue-实例的数据对象-data-有了-el还-没有"}},[t._v("#")]),t._v(" *创建前/后： 在 beforeCreate 阶段， vue 实例的挂载元素 el 和数据对象 data 都为undefined ，还未初始化。在 created 阶段， vue 实例的数据对象 data 有了，el还 没有")]),t._v(" "),e("h4",{attrs:{id:"载入前-后-在-beforemount-阶段-vue-实例的-el-和-data-都初始化了-但还是挂载之前为虚拟的-dom-节点-data-message-还未替换。在-mounted-阶段-vue-实例挂载完成-data-message-成功渲染。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#载入前-后-在-beforemount-阶段-vue-实例的-el-和-data-都初始化了-但还是挂载之前为虚拟的-dom-节点-data-message-还未替换。在-mounted-阶段-vue-实例挂载完成-data-message-成功渲染。"}},[t._v("#")]),t._v(" *载⼊前/后：在 beforeMount 阶段， vue 实例的 $el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点， data.message 还未替换。在 mounted 阶段， vue 实例挂载完成， data.message 成功渲染。")]),t._v(" "),e("h4",{attrs:{id:"更新前-后-当-data-变化时-会触发-beforeupdate-和-updated-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新前-后-当-data-变化时-会触发-beforeupdate-和-updated-方法"}},[t._v("#")]),t._v(" *更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated ⽅法")]),t._v(" "),e("h4",{attrs:{id:"销毁前-后-在执行-destroy-方法后-对-data-的改变不会再触发周期函数-说明此时-vue-实例已经解除了事件监听以及和-dom-的绑定-但是-dom-结构依然存在"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#销毁前-后-在执行-destroy-方法后-对-data-的改变不会再触发周期函数-说明此时-vue-实例已经解除了事件监听以及和-dom-的绑定-但是-dom-结构依然存在"}},[t._v("#")]),t._v(" *销毁前/后：在执⾏ destroy ⽅法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在")]),t._v(" "),e("h2",{attrs:{id:"_4-11-描述组件渲染和更新过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-11-描述组件渲染和更新过程"}},[t._v("#")]),t._v(" 4.11 描述组件渲染和更新过程?")]),t._v(" "),e("h4",{attrs:{id:"渲染组件时-会通过vue-extend方法构建子组件的构造函数-并进行实例化。最终手动调用-mount-进行挂载。更新组件时会进行patchvnode流程-核心就是diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染组件时-会通过vue-extend方法构建子组件的构造函数-并进行实例化。最终手动调用-mount-进行挂载。更新组件时会进行patchvnode流程-核心就是diff算法"}},[t._v("#")]),t._v(" 渲染组件时，会通过Vue.extend方法构建子组件的构造函数，并进行实例化。最终手动调用$mount()进行挂载。更新组件时会进行patchVnode流程.核心就是diff算法")]),t._v(" "),e("h2",{attrs:{id:"_4-12-组件中的-data为什么是一个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-12-组件中的-data为什么是一个函数"}},[t._v("#")]),t._v(" 4.12 组件中的 data为什么是一个函数?")]),t._v(" "),e("h4",{attrs:{id:"同一个组件被复用多次-会创建多个实例。这些实例用的是同一个构造函数-如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同一个组件被复用多次-会创建多个实例。这些实例用的是同一个构造函数-如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。"}},[t._v("#")]),t._v(" 同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果data是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过data函数返回一个对象作为组件的状态。")]),t._v(" "),e("h2",{attrs:{id:"_4-13-vue父子组件生命周期调用顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-13-vue父子组件生命周期调用顺序"}},[t._v("#")]),t._v(" 4.13 Vue父子组件生命周期调用顺序?")]),t._v(" "),e("h4",{attrs:{id:"加载渲染过程-父beforecreate-父created-父beforemount-子beforecreate-子created-子beforemount-子mounted-父mounted"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#加载渲染过程-父beforecreate-父created-父beforemount-子beforecreate-子created-子beforemount-子mounted-父mounted"}},[t._v("#")]),t._v(" 加载渲染过程:父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted")]),t._v(" "),e("h4",{attrs:{id:"子组件更新过程-父beforeupdate-子beforeupdate-子updated-父updated"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#子组件更新过程-父beforeupdate-子beforeupdate-子updated-父updated"}},[t._v("#")]),t._v(" 子组件更新过程:父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated")]),t._v(" "),e("h4",{attrs:{id:"父组件更新过程-父beforeupdate-父updated"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父组件更新过程-父beforeupdate-父updated"}},[t._v("#")]),t._v(" 父组件更新过程: 父beforeUpdate -> 父updated")]),t._v(" "),e("h4",{attrs:{id:"销毁过程-父beforedestroy-子beforedestroy-子destroyed-父destroyed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#销毁过程-父beforedestroy-子beforedestroy-子destroyed-父destroyed"}},[t._v("#")]),t._v(" 销毁过程:父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed")]),t._v(" "),e("h4",{attrs:{id:"组件的调用顺序都是先父后子-渲染完成的顺序肯定是先子后父。组件的销毁操作是先父后子-销毁完成的顺序是先子后父。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件的调用顺序都是先父后子-渲染完成的顺序肯定是先子后父。组件的销毁操作是先父后子-销毁完成的顺序是先子后父。"}},[t._v("#")]),t._v(" 组件的调用顺序都是先父后子,渲染完成的顺序肯定是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。")]),t._v(" "),e("h2",{attrs:{id:"_4-15-vue组件如何通信以及有哪些方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-15-vue组件如何通信以及有哪些方式"}},[t._v("#")]),t._v(" 4.15 Vue组件如何通信以及有哪些方式?")]),t._v(" "),e("h4",{attrs:{id:"父子间通信-父-子通过props、子-父-on、-emit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父子间通信-父-子通过props、子-父-on、-emit"}},[t._v("#")]),t._v(" *父子间通信 父->子通过props、子-> 父$on、$emit")]),t._v(" "),e("h4",{attrs:{id:"获取父子组件实例的方式-parent、-children"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取父子组件实例的方式-parent、-children"}},[t._v("#")]),t._v(" *获取父子组件实例的方式$parent、$children")]),t._v(" "),e("h4",{attrs:{id:"在父组件中提供数据子组件进行消费-provide、inject"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在父组件中提供数据子组件进行消费-provide、inject"}},[t._v("#")]),t._v(" *在父组件中提供数据子组件进行消费 Provide、inject")]),t._v(" "),e("h4",{attrs:{id:"ref获取实例的方式调用组件的属性或者方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ref获取实例的方式调用组件的属性或者方法"}},[t._v("#")]),t._v(" *Ref获取实例的方式调用组件的属性或者方法")]),t._v(" "),e("h4",{attrs:{id:"event-bus-实现跨组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-bus-实现跨组件通信"}},[t._v("#")]),t._v(" *Event Bus 实现跨组件通信")]),t._v(" "),e("h4",{attrs:{id:"vuex状态管理实现通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex状态管理实现通信"}},[t._v("#")]),t._v(" *Vuex状态管理实现通信")]),t._v(" "),e("h2",{attrs:{id:"_4-16-vue-js-怎么快速定位哪个组件出现性能问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-16-vue-js-怎么快速定位哪个组件出现性能问题"}},[t._v("#")]),t._v(" 4.16 Vue.js 怎么快速定位哪个组件出现性能问题?")]),t._v(" "),e("h4",{attrs:{id:"用-timeline-工具。-大意是通过-timeline-来查看每个函数的调用时常-定位出哪个函数的问题-从而能判断哪个组件出了问题。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用-timeline-工具。-大意是通过-timeline-来查看每个函数的调用时常-定位出哪个函数的问题-从而能判断哪个组件出了问题。"}},[t._v("#")]),t._v(" ⽤ timeline ⼯具。 ⼤意是通过 timeline 来查看每个函数的调⽤时常，定位出哪个函数的问题，从⽽能判断哪个组件出了问题。")]),t._v(" "),e("h2",{attrs:{id:"_4-17-请列举出3个vue中常用的生命周期钩子函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-17-请列举出3个vue中常用的生命周期钩子函数"}},[t._v("#")]),t._v(" 4.17 请列举出3个Vue中常用的生命周期钩子函数?")]),t._v(" "),e("h4",{attrs:{id:"created-实例已经创建完成之后调用-在这一步-实例已经完成数据观测-属性和方法的运-算-watch-event-事件回调-然而-挂载阶段还没有开始-el-属性目前还不可⻅。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#created-实例已经创建完成之后调用-在这一步-实例已经完成数据观测-属性和方法的运-算-watch-event-事件回调-然而-挂载阶段还没有开始-el-属性目前还不可⻅。"}},[t._v("#")]),t._v(" created : 实例已经创建完成之后调⽤,在这⼀步,实例已经完成数据观测, 属性和⽅法的运 算, watch/event 事件回调. 然⽽, 挂载阶段还没有开始, $el 属性⽬前还不可⻅。")]),t._v(" "),e("h4",{attrs:{id:"mounted-el-被新创建的-vm-el-替换-并挂载到实例上去之后调用该钩子。如果-root-实例挂载了一个文档内元素-当-mounted-被调用时-vm-el-也在文档内。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mounted-el-被新创建的-vm-el-替换-并挂载到实例上去之后调用该钩子。如果-root-实例挂载了一个文档内元素-当-mounted-被调用时-vm-el-也在文档内。"}},[t._v("#")]),t._v(" mounted : el 被新创建的 vm.$el 替换，并挂载到实例上去之后调⽤该钩⼦。如果 root 实例挂载了⼀个⽂档内元素，当 mounted 被调⽤时 vm.$el 也在⽂档内。")]),t._v(" "),e("h4",{attrs:{id:"activated-keep-alive-组件激活时用。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#activated-keep-alive-组件激活时用。"}},[t._v("#")]),t._v(" activated : keep-alive 组件激活时用。")]),t._v(" "),e("h2",{attrs:{id:"_4-18-vue-js-和-react-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-18-vue-js-和-react-区别"}},[t._v("#")]),t._v(" 4.18 Vue.js 和 react 区别?")]),t._v(" "),e("h4",{attrs:{id:"相同点-都支持-ssr-都有-vdom-组件化开发-实现-webcomponents-规范-数据驱-动等。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相同点-都支持-ssr-都有-vdom-组件化开发-实现-webcomponents-规范-数据驱-动等。"}},[t._v("#")]),t._v(" 相同点:都⽀持 ssr ，都有 vdom ，组件化开发，实现 webComponents 规范，数据驱 动等。")]),t._v(" "),e("h4",{attrs:{id:"不同点-vue-是双向数据流-当然为了实现单数据流方便管理组件状态-vuex-便出现了-react-是单向数据流。-vue-的-vdom-是追踪每个组件的依赖关系-不会渲染整个组件树-react-每当应该状态被改变时-全部子组件都会-re-render"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不同点-vue-是双向数据流-当然为了实现单数据流方便管理组件状态-vuex-便出现了-react-是单向数据流。-vue-的-vdom-是追踪每个组件的依赖关系-不会渲染整个组件树-react-每当应该状态被改变时-全部子组件都会-re-render"}},[t._v("#")]),t._v(" 不同点：vue 是双向数据流（当然为了实现单数据流⽅便管理组件状态， vuex 便出现了）， react 是单向数据流。 vue 的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树， react 每当应该状态被改变时，全部⼦组件都会 re-render")]),t._v(" "),e("h2",{attrs:{id:"_4-19-vue中事件绑定的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-19-vue中事件绑定的原理"}},[t._v("#")]),t._v(" 4.19 Vue中事件绑定的原理?")]),t._v(" "),e("h4",{attrs:{id:"原生dom事件的绑定-采用的是addeventlistener实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原生dom事件的绑定-采用的是addeventlistener实现"}},[t._v("#")]),t._v(" 原生dom事件的绑定,采用的是addEventListener实现")]),t._v(" "),e("h4",{attrs:{id:"组件绑定事件采用的是-on方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件绑定事件采用的是-on方法"}},[t._v("#")]),t._v(" 组件绑定事件采用的是$on方法")]),t._v(" "),e("h2",{attrs:{id:"_4-20-为什么v-for和v-if不能连用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-20-为什么v-for和v-if不能连用"}},[t._v("#")]),t._v(" 4.20 为什么V-for和v-if不能连用?")]),t._v(" "),e("h4",{attrs:{id:"v-for会比v-if的优先级高一些-如果连用的话会把v-if给每个元素都添加一下-会造成性能问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-for会比v-if的优先级高一些-如果连用的话会把v-if给每个元素都添加一下-会造成性能问题"}},[t._v("#")]),t._v(" v-for会比v-if的优先级高一些,如果连用的话会把v-if给每个元素都添加一下,会造成性能问题")]),t._v(" "),e("h2",{attrs:{id:"_4-21-ajax请求放在哪个生命周期中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-21-ajax请求放在哪个生命周期中"}},[t._v("#")]),t._v(" 4.21 ajax请求放在哪个生命周期中?")]),t._v(" "),e("h4",{attrs:{id:"在created的时候-视图中的dom并没有渲染出来-所以此时如果直接去操dom节点-无法找到相关的元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在created的时候-视图中的dom并没有渲染出来-所以此时如果直接去操dom节点-无法找到相关的元素"}},[t._v("#")]),t._v(" 在created的时候，视图中的dom并没有渲染出来，所以此时如果直接去操dom节点，无法找到相关的元素")]),t._v(" "),e("h4",{attrs:{id:"在mounted中-由于此时dom已经渲染出来了-所以可以直接操作dom节点。一般情况下都放到mounted中-保证逻辑的统一性-因为生命周期是同步执行的-ajax是异步执行的。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在mounted中-由于此时dom已经渲染出来了-所以可以直接操作dom节点。一般情况下都放到mounted中-保证逻辑的统一性-因为生命周期是同步执行的-ajax是异步执行的。"}},[t._v("#")]),t._v(" 在mounted中，由于此时dom已经渲染出来了，所以可以直接操作dom节点。一般情况下都放到mounted中,保证逻辑的统一性,因为生命周期是同步执行的，ajax是异步执行的。")]),t._v(" "),e("h2",{attrs:{id:"_4-22-action-和-mutation区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-22-action-和-mutation区别"}},[t._v("#")]),t._v(" 4.22 action 和 mutation区别?")]),t._v(" "),e("h4",{attrs:{id:"mutation是同步更新数据-内部会进行是否为异步方式更新数据的检测-。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutation是同步更新数据-内部会进行是否为异步方式更新数据的检测-。"}},[t._v("#")]),t._v(" mutation是同步更新数据(内部会进行是否为异步方式更新数据的检测)。")]),t._v(" "),e("h4",{attrs:{id:"action-异步操作-可以获取数据后调佣mutation提交最终数据。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#action-异步操作-可以获取数据后调佣mutation提交最终数据。"}},[t._v("#")]),t._v(" action 异步操作，可以获取数据后调佣mutation提交最终数据。")])])}),[],!1,null,null,null);a.default=s.exports}}]);